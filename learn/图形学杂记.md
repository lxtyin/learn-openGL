

先行笔记：线性代数的本质



### 一些杂

#### 3维叉乘顺序

通常我们使用的是右手定则决定叉乘方向，且定义三维坐标系下 $x\times y=z$，同时还有 $y\times z=x$，$z\times y = x$（注意不是 $y\times z=x$）

如果反复写很多遍 $xyzxyzxyz$，可以发现任意相邻两个叉乘可以得到第三个（循环对称性）

许多时候我们会利用对称性来“照抄”（如写绕y轴旋转的矩阵），要注意这三个轴是循环对称而非按顺序对称的。



#### 四元数

四元数是用来表达旋转的，其主要用途在于计算两个旋转之间的插值（用旋转矩阵很难计算）

正常用矩阵表达Transform的话，只需要掌握矩阵和四元数之间的转换方法即可（先画饼）。



#### LookAt矩阵/View变换

给定相机位置，以及表示朝向的三个轴（给定两个即可（前向和上轴）），如何构建相机的Transform和观察变换矩阵？

位移略过不谈，旋转时将三个轴填入矩阵即可。

值得注意的是，如果我们需要其逆变换（mv变换时常用），只需要对左上矩阵做转置。

因为旋转矩阵是一个正交矩阵，有 $A^{-1}=A^T$



### 投影

“投影”直观上容易被理解为将三维空间物体变换到二维屏幕的过程（可以有这样一种降维的线性变换），但如果直接用矩阵来做这样一件事，不方便处理深度信息（遮挡效果）。

故实际上我们说的投影矩阵，是将三维空间中的一个长方体或平头截体（观察区域）映射到标准立方体（Canonical Cube，$[-1, 1]^3$）的过程，这个空间也叫**裁剪空间**。映射到这里的好处是方便进行后续操作。



#### 正交投影

将一个长方体映射到 $[-1,1]^3$，比较简单

很多时候我们会在正交投影时把 $z$ 倒过来，这样摄像机朝 $-z$ 方向，而深度缓冲中的 $z$ 越小表示离摄像机越近。



#### 透视投影

透视投影的观察区域是一个平头截体，我们希望也使用一种（四维矩阵可表示的）线性变换将它映射到 $[-1,1]^3$。

思路：首先进行的是一个“压扁”的缩放过程，令远处的平面缩放幅度更大，近平面不变，使得平头截体变成一个长方体，随后进行正交投影。

最简单的想法：让一条观察射线（朝-z方向）上所有 $x,y$ 坐标缩放后都相同，先假定 $z$ 轴不变。

通过相似三角形容易计算出新坐标应该为 $(n/z\times x,n/z\times y,z)$

编出一个变换矩阵，其中参数 $n$ 为近平面的 $z$ 坐标（负值！）
$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
?&?&?&?\\
0&0&1&0\\
\end{bmatrix}
\times
\begin{bmatrix}
x\\
y\\
z\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
n/z\times x\\
n/z\times y\\
z\\
1\\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
nx\\
ny\\
z^2\\
z\\
\end{bmatrix}
$$

我们发现1，2，4行的参数都很容易确定，但是第三行似乎没法搞？

问题出现了，这样的变换似乎不是一个线性变换（即使在四维下）

那么只能放弃追求 $z$ 轴不变了。

实际的投影矩阵要求只有：近平面坐标不变，以及远平面的z轴（$f$）不变

$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
0&0&A&B\\
0&0&1&0\\
\end{bmatrix}
\times
\begin{bmatrix}
x\\
y\\
n\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
nx\\
ny\\
n^2\\
n\\
\end{bmatrix}
$$

$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
0&0&A&B\\
0&0&1&0\\
\end{bmatrix}
\times
\begin{bmatrix}
x\\
y\\
f\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
nx\\
ny\\
f^2\\
f\\
\end{bmatrix}
$$
$$
An+B=n^2\\
Af+B=f^2\\
A = n + f\\
B = -nf
$$



由此得到了这个压缩矩阵：
$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
0&0&n+f&-nf\\
0&0&1&0\\
\end{bmatrix}
$$

现在得到需要的矩阵了，它满足变换后**近平面不变，远平面 $z$ 不变，且中间的 $z$ 坐标依旧保持顺序**的性质，变换到 $[-1,1]^3$ 之后大概长这样：

![projection](http://lxtyin.ac.cn/img/Gemo/projection.png)

（图源网络且魔改）

可以看到，虽然它让中间部分保持了顺序，深度测试不会出错，但是不均匀地拉伸会让三角形内部的**插值**有很大问题，需要进行下一节所说的透视插值矫正。

但这样的不均匀也不是没有好处：它将深度测试中我们所说的“非均匀精度分配”直接实现了！

> LearnOpenGL：
>
> 可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。

再次体会到投影矩阵的强大

手动推导一下这个深度变换式子：

“压扁”后：$z_1 = n+f-nf/z$

标准坐标系内：$z_2=-1+2\times (n-z_1)/(n-f)$

如果深度值范围是0-1：$z_3 = (z_2+1)/2 = (n-z_1) / (n - f) = \frac{(1/z-1/n)}{(1/f-1/n)}$

和LearnOpenGL上给出的式子完全一致！简洁优雅



##### 透视插值矫正

图不想画了，二维情况下的计算不难，推广到三维也很合理，直接给出结论：

设屏幕空间下，某点的重心坐标为 $a,b,c$，则该点的实际深度值 $w_0$
$$
\frac{1}{w_0}=\frac{a}{w_1}+\frac{b}{w_2}+\frac{c}{w_3}
$$
插值结果（假设对 $p$ 这个属性插值）：
$$
p_0 = w_0\times(\frac{ap_1}{w_1}+\frac{bp_2}{w_2}+\frac{cp_3}{w_3})
$$
[推导链接](https://zhuanlan.zhihu.com/p/403259571)

**注意**：这里用 $w$ 表示顶点在**透视投影变换前**的 $z$ 坐标，为顶点的实际深度，要和变换到标准设备坐标下之后的 $z$ 坐标作区分。

这个 $w_{123}$ 是怎么留下来的呢？还记得投影矩阵变换后的 $w$ 分量吗，它恰恰等于原先的 $z$。我们通常会在齐次除法中保留它不变（因为后面也不会用到线性变换了，留着也没关系（视口变换可以直接操作）。

最后，深度测试使用的深度值并不是 $w$（如果用 $w$ 就做不到非均匀分配精度了），而是NDC下的 $z$ 坐标。我们可以用三个顶点的 $z$ 坐标按照上述方式插值到单点的 $z$ 坐标，它早在投影时便完成了精度的分配。



### 反走样

可以采用先模糊，再采样的方法。

理解走样的来源是：采样频率跟不上信号变化的速率，两个采样点之间信号可能发生了很多未被采集到的变化。

模糊操作本身是对信号做了一个均值处理，此时一个像素上包含了其附近像素的信息，故模糊后采样能非常有效地缓解锯齿。

另一个角度：模糊操作相当于一个低通滤波，除去了高频部分。而锯齿现象本质是源于对高频信号采样时的信息缺失。

从这两个角度都可以理解：为什么先采样，后模糊不行。

模糊的一种办法是对连续图像取平均得到离散结果。具体到三角形上，可以在每个像素处根据覆盖三角形的面积来改变颜色，再具体的，可以在每个像素中设多个采样点（4个，9个..），看几个在三角形内来粗略计算面积（MSAA方法）。



### 着色

- Flat Shading，逐三角形着色，每个三角形的法线都完全一样，适用于有锐利转折的平面。
- Gouraud Shading，逐顶点着色，在顶点处计算出颜色，将颜色/光强插值到各个片元。
  - 双线性光强插值指的也是这个

- Phong Shading，逐像素着色，将顶点法线插值到像素上后逐像素计算颜色。效果最平滑，也比较常用。
  - 双线性法向插值指的也是这个


顶点法向量：近似地由各个相邻面的法向量平均得出。



####  具体插值方法

##### 重心坐标

重心坐标（Baycentric Coordinates）定理：即三角形中任意一点 $X$，都可以表示成 $X=aA+bB+cC$，其中 $ABC$ 为三个顶点的坐标向量，$abc$ 为系数且满足 $a+b+c=1$。

一个顶点的重心坐标可以用这样的 $(a,b,c)$ 来表示，实际上，可以根据顶点对面的三角形面积占比来快速计算 $abc$（具体图去百度找一下）

重心坐标本身就代表了三个顶点在此点所占的权重，故可以轻松得到插值比例。



##### 双线性插值

具体思路：先插值一次得到每条线上的值，再插值得到每个位置上的值。

可以利用扫描线算法，进行增量插值。



#### 图像放大方法

高分辨率对象上应用低分辨率图像时常用算法：

- Nearest：取最近像素
- Linear：线性插值，按距离分配权重，取周边像素均值
  - BiLinear：对于图像而言的双线性插值，按水平和垂直线性插值两趟
- Bicubic：双三次插值，效果更好，原理涉及信号系统（暂略）

#### 图像缩小方法

低分辨率对象上应用高分辨率图像，更一般地：渲染远处物体时都会遇到这种情况（一个采样点覆盖的范围过大，也等同于采样频率不足，导致走样）。

之前说到，反走样可以使用模糊操作，但我们需要对越远的地方模糊更多，于是有了**mipmap**（多级渐远纹理）。

#### Mipmap

即对于一张纹理，事先将其缩放为一半、1/4、1/8...（采用模糊方式缩放），将这些缩小的纹理全都存放起来。这些全部存放的空间仅为原先的 $4/3$ 倍。

具体渲染时，对于一个即将渲染的像素（已经知道了其uv），可以取其相邻像素的uv，计算出这个像素实际需要覆盖的矩形大小。

注意这是一种粗略的近似，**像素实际覆盖的纹理区域不一定是矩形**，而mipmap方法根本上是对一个矩形区域求了均值，故这里并不完全准确。

假设现在这个像素需要覆盖一个宽为 $L$ 的正方形，那么实际如何利用多级渐远纹理取样？

- Trilinear：三线性插值，计算 $D=log_2 L$，即要在第 $D$ 层纹理上取样比较合理，$D$ 为浮点数时就，在 $\lfloor D\rfloor$ 和 $\lfloor D\rfloor +1$ 层分别进行双线性插值，然后再依据 $D$ 插值一次得到实际颜色。

#### 各向异性过滤

Mipmap只能求正方形区域的均值，故在覆盖斜着的、长的纹理时会出现overblur（过度模糊）的现象。

各向异性过滤额外预处理了一些不等比缩放的纹理（具体图百度），空间翻到了3倍，能很好地处理覆盖区域为长方形的情况，但对于斜长的情况还是会overblur。

EWA filtering是一种更复杂的方法，具体略过。



### 纹理应用

#### 立方体贴图

可以用来做天空盒、环境光等**全景贴图**。

在一个起点朝各个方向看到的东西可以用一个球面来描述，但球面不好存储（展开会有扭曲，不直观），可以将各个方向的向量延伸后对应到一个立方体上，用这个立方体来存储全景图。

立方体贴图当然可以用一个向量来取样，得到的效果与球形图完全一致，没有任何问题。



#### 法线贴图

字面意思很好理解，用纹理来直接指定每一个像素上的法线，能在平面上做到丰富的光照细节。

但直接在模型空间下指定法线，不是太好。例如当一个立方体的六个面都使用相同的纹理时，我们却不得不为它分配六张不同的法线贴图。

一个更好的坐标系是切线空间，在切线空间下表示法线，可以只关注平面，而不关心其方向。

##### 切线空间

![1](http://lxtyin.ac.cn/img/Gemo/tangent.png)

如图所示，绿色为空间中任一个三角形，灰色部分为将这个三角形的纹理（uv）直接贴上去的样子，我们定义沿纹理 $x$ 轴方向的单位向量为切线 $T$（Tangent），同时沿纹理 $y$ 轴方向的单位向量为 $B$（bitangent），三角形的法线朝向 $+z$ 方向，这样的空间叫做切线空间。

切线 $T$ 通常作为顶点数据的一部分，会在模型中给定，如果希望自己算，也可以通过上图中三角形的另外两点的顶点坐标和uv列式计算得到。

具体式子可以来这边找到 https://learnopengl.com/Advanced-Lighting/Normal-Mapping

使用切线空间来应用法线贴图的流程大概是这样的：

- 将 Normal、Tangent 以及MVP这类的矩阵传入顶点着色器，也可以预先将法线矩阵（3x3的逆的转置的那个）计算好传入。
- 叉乘得到 Bitangent，将三个轴都变换到世界坐标系下（同法线变换方法），得到 TBN 矩阵
- 把 TBN 矩阵传入片段着色器
- 在片段着色器中，从 Normal map 中采样法线，然后让这个法线左乘 TBN 矩阵即可得到世界坐标系下的法线。
  - TBN是一个仅有旋转的3x3矩阵，故不需要再进行法线变换。


如果在观察坐标系下计算光照，也是同理。

我们通常看到的法线贴图偏蓝色，正是因为切线空间下法线大多朝向 $+z$ 方向（0, 0, 1），仅对一部分细节有所扰动。

在多个三角面共享顶点时，我们用类似法线的处理思路：如果希望有平滑的效果，就平均一下，如果要锐利就把公共顶点拆开。



#### 凹凸贴图

更直观的做法：不是直接指定每个像素的法线，而是指定每个像素的高度偏移，然后自行计算法线。

计算法线同样在切线空间下进行，假设原法线朝向 $(0, 0, 1)$，可以在凹凸贴图上做个差分来计算新法线。
$$
dp/du=c_1\times (h(u+1)-h(u))\\
dp/dv = c_2\times (h(v+1)-h(v))\\
n=(-dp/du,-dp/dv,1)
$$

#### 阴影贴图

实现阴影的经典办法，但是有非常多弊端。

思路：首先在光源位置观察场景，走一遍光栅化流程（但不着色），渲染出一张阴影贴图，每个像素上记录深度。

然后再正常渲染场景，对于每个片段，我们再将这个片段变换到光源的观察坐标系下，做一次投影，找出这个片段在阴影贴图上对应的位置。然后对比深度值，以判断这个像素是否能被光源看到。

上述是最简单的阴影贴图逻辑，它只能处理平行光，只考虑了单光源，只能产生硬阴影，且依赖阴影贴图的分别率，容易产生锯齿。

##### 多光源

本身我们在着色时，多光源就是分别着色后叠加的。因此阴影只对每个光源分开考虑就好。

##### 软阴影



### 画饼

视差贴图（法线贴图进阶）

静态物体提前烘焙、环境光遮蔽

