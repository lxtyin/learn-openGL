

先行笔记：线性代数的本质



#### 3维叉乘顺序

通常我们使用的是右手定则决定叉乘方向，且定义三维坐标系下 $x\times y=z$，同时还有 $y\times z=x$，$z\times y = x$（注意不是 $y\times z=x$）

如果反复写很多遍 $xyzxyzxyz$，可以发现任意相邻两个叉乘可以得到第三个（循环对称性）

许多时候我们会利用对称性来“照抄”（如写绕y轴旋转的矩阵），要注意这三个轴是循环对称而非按顺序对称的。



#### 四元数

四元数是用来表达旋转的，其主要用途在于计算两个旋转之间的插值（用旋转矩阵很难计算）

正常用矩阵表达Transform的话，只需要掌握矩阵和四元数之间的转换方法即可（先画饼）。



#### LookAt矩阵/View变换

给定相机位置，以及表示朝向的三个轴（给定两个即可（前向和上轴）），如何构建相机的Transform和观察变换矩阵？

位移略过不谈，旋转时将三个轴填入矩阵即可。

值得注意的是，如果我们需要其逆变换（mv变换时常用），只需要对左上矩阵做转置。

因为旋转矩阵是一个正交矩阵，有 $A^{-1}=A^T$



#### 投影矩阵

“投影”直观上容易被理解为将三维空间物体变换到二维屏幕的过程（可以有这样一种降维的线性变换），但如果直接用矩阵来做这样一件事，不方便处理深度信息（遮挡效果）。

故实际上我们说的投影矩阵，是将三维空间中的一个长方体或平头截体（观察区域）映射到标准立方体（Canonical Cube，$[-1, 1]^3$）的过程，这个空间也叫**裁剪空间**。映射到这里的好处是方便进行后续操作。



##### 正交投影

将一个长方体映射到 $[-1,1]^3$，比较简单



##### 透视投影

透视投影的观察区域是一个平头截体，我们希望也使用一种（四维矩阵可表示的）线性变换将它映射到 $[-1,1]^3$。

思路：首先进行的是一个“压扁”的缩放过程，令远处的平面缩放幅度更大，近平面不变，使得平头截体变成一个长方体，随后进行正交投影。

最简单的想法：用相似三角形，让一条观察射线（朝-z方向）上所有 $x,y$ 坐标缩放后都相同，先假定 $z$ 轴不变

编出一个变换矩阵，其中参数 $n$ 为近平面的 $z$ 坐标
$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
?&?&?&?\\
0&0&1&0\\
\end{bmatrix}
\times
\begin{bmatrix}
x\\
y\\
z\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
nx\\
ny\\
z^2\\
z\\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
n/z\times x\\
n/z\times y\\
z\\
1\\
\end{bmatrix}
$$

我们发现1，2，4行的参数都很容易确定，但是第三行似乎没法搞？

问题出现了，这样的变换似乎不是一个线性变换（即使在四维下）

那么只能放弃追求 $z$ 轴不变了。

实际的投影矩阵要求只有：近平面坐标不变，以及远平面的z轴（$f$）不变

$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
0&0&A&B\\
0&0&1&0\\
\end{bmatrix}
\times
\begin{bmatrix}
x\\
y\\
n\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
nx\\
ny\\
n^2\\
n\\
\end{bmatrix}
$$

$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
0&0&A&B\\
0&0&1&0\\
\end{bmatrix}
\times
\begin{bmatrix}
x\\
y\\
f\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
nx\\
ny\\
f^2\\
f\\
\end{bmatrix}
$$
$$
An+B=n^2\\
Af+B=f^2\\
A = n + f\\
B = -nf
$$



由此得到了这个压缩矩阵：
$$
\begin{bmatrix}
n&0&0&0\\
0&n&0&0\\
0&0&n+f&-nf\\
0&0&1&0\\
\end{bmatrix}
$$

#### 投影后

经过一个简单的平移+缩放，可以将 $x,y$ 从 $[-1,1]$ 映射到 $[0,w]$ 和 $[0,h]$（屏幕空间），这被称为视口变换。

然后对所有的三角形进行光栅化。

对于三角形片元来说，只需要枚举每个像素的中点，利用叉乘判断它是否在三角形内部即可。可以只枚举bounding-box内的像素。

##### 反走样

可以采用先模糊，再采样的方法。

理解走样的来源是：采样频率跟不上信号变化的速率，两个采样点之间信号可能发生了很多未被采集到的变化。

模糊操作本身是对信号做了一个均值处理，此时一个像素上包含了其附近像素的信息，故模糊后采样能非常有效地缓解锯齿。

另一个角度：模糊操作相当于一个低通滤波，除去了高频部分。而锯齿现象本质是源于对高频信号采样时的信息缺失。

从这两个角度都可以理解：为什么先采样，后模糊不行。

模糊的一种办法是对连续图像取平均得到离散结果。具体到三角形上，可以在每个像素处根据覆盖三角形的面积来改变颜色，再具体的，可以在每个像素中设多个采样点（4个，9个..），看几个在三角形内来粗略计算面积（MSAA方法）。



#### 着色

- Flat Shading，逐三角形着色，每个三角形的法线都完全一样，适用于有锐利转折的平面。
- Gouraud Shading，逐顶点着色，在顶点处计算出颜色，将颜色/光强插值到各个片元。
  - 双线性光强插值指的也是这个

- Phong Shading，逐像素着色，将顶点法线插值到像素上后逐像素计算颜色。效果最平滑，也比较常用。
  - 双线性法向插值指的也是这个


顶点法向量：近似地由各个相邻面的法向量平均得出。



#####  具体插值方法

###### 重心坐标

重心坐标（Baycentric Coordinates）定理：即三角形中任意一点 $X$，都可以表示成 $X=aA+bB+cC$，其中 $ABC$ 为三个顶点的坐标向量，$abc$ 为系数且满足 $a+b+c=1$。

一个顶点的重心坐标可以用这样的 $(a,b,c)$ 来表示，实际上，可以根据顶点对面的三角形面积占比来快速计算 $abc$（具体图去百度找一下）

重心坐标本身就代表了三个顶点在此点所占的权重，故可以轻松得到插值比例。



###### 双线性插值

具体思路：先插值一次得到每条线上的值，再插值得到每个位置上的值。

可以利用扫描线算法，进行增量插值。



##### 插值矫正

投影变换时会对三角形进行拉伸，在拉伸后计算重心坐标并不太正确。应当应用逆变换，在投影前的三维空间中计算当前片段的重心坐标比较合理。（暂时没有非常理解）

##### 图像放大方法

高分辨率对象上应用低分辨率图像时常用算法：

- Nearest：取最近像素
- Linear：线性插值，按距离分配权重，取周边像素均值
  - BiLinear：对于图像而言的双线性插值，按水平和垂直线性插值两趟
- Bicubic：双三次插值，效果更好，原理涉及信号系统（暂略）

##### 图像缩小方法

低分辨率对象上应用高分辨率图像，更一般地：渲染远处物体时都会遇到这种情况（一个采样点覆盖的范围过大，也等同于采样频率不足，导致走样）。

之前说到，反走样可以使用模糊操作，但我们需要对越远的地方模糊更多，于是有了**mipmap**（多级渐远纹理）。

##### Mipmap

即对于一张纹理，事先将其缩放为一半、1/4、1/8...（采用模糊方式缩放），将这些缩小的纹理全都存放起来。这些全部存放的空间仅为原先的 $4/3$ 倍。

具体渲染时，对于一个即将渲染的像素（已经知道了其uv），可以取其相邻像素的uv，计算出这个像素实际需要覆盖的矩形大小。

注意这是一种粗略的近似，**像素实际覆盖的纹理区域不一定是矩形**，而mipmap方法根本上是对一个矩形区域求了均值，故这里并不完全准确。

假设现在这个像素需要覆盖一个宽为 $L$ 的正方形，那么实际如何利用多级渐远纹理取样？

- Trilinear：三线性插值，计算 $D=log_2 L$，即要在第 $D$ 层纹理上取样比较合理，$D$ 为浮点数时就，在 $\lfloor D\rfloor$ 和 $\lfloor D\rfloor +1$ 层分别进行双线性插值，然后再依据 $D$ 插值一次得到实际颜色。

##### 各向异性过滤

Mipmap只能求正方形区域的均值，故在覆盖斜着的、长的纹理时会出现overblur（过度模糊）的现象。

各向异性过滤额外预处理了一些不等比缩放的纹理（具体图百度），空间翻到了3倍，能很好地处理覆盖区域为长方形的情况，但对于斜长的情况还是会overblur。

EWA filtering是一种更复杂的方法，具体略过。



#### 立方体贴图

可以用来做天空盒、环境光等**全景贴图**。

在一个起点朝各个方向看到的东西可以用一个球面来描述，但球面不好存储（展开会有扭曲，不直观），可以将各个方向的向量延伸后对应到一个立方体上，用这个立方体来存储全景图。

立方体贴图当然可以用一个向量来取样，得到的效果与球形图完全一致，没有任何问题。



#### 法线贴图

字面意思很好理解，用纹理来直接指定每一个像素上的法线，能在平面上做到丰富的光照细节。

但直接在模型空间下指定法线，不是太好。例如当一个立方体的六个面都使用相同的纹理时，我们却不得不为它分配六张不同的法线贴图。

一个更好表示法线的坐标系是切线空间。

##### 切线空间

![1](http://lxtyin.ac.cn/img/Gemo/tangent.png)

如图所示，绿色为空间中任一个三角形，灰色部分为将这个三角形的纹理（uv）直接贴上去的样子，我们定义沿纹理 $x$ 轴方向的单位向量为切线 $T$（Tangent），同时沿纹理 $y$ 轴方向的单位向量为 $B$（bitangent），三角形的法线朝向 $+z$ 方向，这样的空间叫做切线空间。

切线 $T$ 通常作为顶点数据的一部分，会在模型中给定，如果希望自己算，也可以通过上图中三角形的另外两点的顶点坐标和uv列式计算得到。

具体式子可以来这边找到 https://learnopengl.com/Advanced-Lighting/Normal-Mapping

使用切线空间来应用法线贴图的流程大概是这样的：

- 将 Normal、Tangent 以及MVP这类的矩阵传入顶点着色器，也可以预先将法线矩阵（3x3的逆的转置的那个）计算好传入。
- 叉乘得到 Bitangent，将三个轴都变换到世界坐标系下（同法线变换方法），得到 TBN 矩阵
- 把 TBN 矩阵传入片段着色器
- 在片段着色器中，从 Normal map 中采样法线，然后让这个法线左乘 TBN 矩阵即可得到世界坐标系下的法线。

如果在观察坐标系下计算光照，也是同理。

我们通常看到的法线贴图偏蓝色，正是因为切线空间下法线大多朝向 $+z$ 方向（0, 0, 1），仅对一部分细节有所扰动。

在多个三角面共享顶点时，我们用类似法线的处理思路：如果希望有平滑的效果，就平均一下，如果要锐利就把公共顶点拆开。



## 画饼

视差贴图（法线贴图进阶）

静态物体提前烘焙、环境光遮蔽
